<!DOCTYPE html>

<html lang="en">
<head>
<title>Web VR boilerplate (Cardboard and Oculus)</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<style>
body {
  background-color: #000;
  color: #fff;
  margin: 0px;
  padding: 0;
  overflow: hidden;
}
</style>
</head>

<body>
</body>

<!--
  three.js 3d library
  -->
<script src="js/deps/three.min.73.js"></script>
<script src="js/deps/stats.min.js"></script>

<!--
  VRControls.js acquires positional information from connected VR devices and applies the transformations to a three.js camera object.
   -->
<!--<script src="js/deps/PhoneVR.js"></script>-->   
<script src="js/deps/VRControls.js"></script>

<!--
  VREffect.js handles stereo camera setup and rendering.
  -->
<script src="js/deps/VREffect.js"></script>

<!--
  A polyfill for WebVR using the Device{Motion,Orientation}Event API.
  -->
<script src="js/deps/webvr-polyfill.js"></script>

<!--
  Helps enter and exit VR mode, provides best practices while in VR.
  -->
<script src="js/webvr-manager.js"></script>
<script src="js/texture_animator.js"></script>
<script src="js/mirror.js"></script>

<script>

//var panoramasArray = ["car1.jpg","car2.jpg","car3.jpg"];
var panoramasArray = ["car1.jpg"];
var panoramaNumber = Math.floor(Math.random()*panoramasArray.length);

var container = document.getElementById('container');
container = document.body; 

var w = container.offsetWidth || window.innerWidth;
var h = container.offsetHeight || window.innerHeight;

//Setup three.js WebGL renderer
var renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(window.devicePixelRatio);
var origRenderFunc = renderer.render;

// Append the canvas element created by the renderer to document body element.
//document.body.appendChild(renderer.domElement);
container.appendChild(renderer.domElement);

// Create a three.js scene.
var scene = new THREE.Scene();

// Create a three.js camera.
var camera = new THREE.PerspectiveCamera(75, w / h, 0.3, 10000);

// Apply VR headset positional data to camera.
var controls = new THREE.VRControls(camera);


// Apply VR stereo rendering to renderer.
var effect = new THREE.VREffect(renderer);
effect.setSize(w, h);

// Create a VR manager helper to enter and exit VR mode.
var manager = new WebVRManager(renderer, effect);

var clock = new THREE.Clock();


// creation of a big sphere geometry
var sphere = new THREE.SphereGeometry(100, 100, 40, 1.5);
sphere.applyMatrix(new THREE.Matrix4().makeScale(-1, 1, 1));
 
// creation of the sphere material
var sphereMaterial = new THREE.MeshBasicMaterial();
sphereMaterial.map = THREE.ImageUtils.loadTexture(panoramasArray[panoramaNumber])
 
// geometry + material = mesh (actual object)
var sphereMesh = new THREE.Mesh(sphere, sphereMaterial);
scene.add(sphereMesh);



//sample 3 d object with animated texture
var logo = (new THREE.TextureLoader()).load("kbb1024x128.png");
var annie = new TextureAnimator( logo, 8, 1, 8, 75 ); // texture, #horiz, #vert, #total, duration.


var materials = [  
  new THREE.MeshBasicMaterial({color: 0x000484}),
 new THREE.MeshBasicMaterial({map: logo}),   
  new THREE.MeshBasicMaterial({color: 0x000464}),  
  new THREE.MeshBasicMaterial({color: 0x000444}),
  new THREE.MeshBasicMaterial({color: 0x000424}),
  new THREE.MeshBasicMaterial({color: 0x000404})

];

var cube = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1.5, 1.5), new THREE.MeshFaceMaterial( materials ) );
cube.position.z = -5;
cube.position.x = 5;
scene.add(cube);



// create mirror v1
/*
  var mirrorBox = new THREE.BoxGeometry(2.5, 0.5, 0.1);
  mirrorCubeCamera = new THREE.CubeCamera( 1, 5000, 512 );
  mirrorCubeCamera.renderTarget.minFilter = THREE.LinearMipMapLinearFilter;
  scene.add( mirrorCubeCamera );

  var mirrorCubeMaterial = new THREE.MeshBasicMaterial( { envMap: mirrorCubeCamera.renderTarget } );
  mirrorCube = new THREE.Mesh( mirrorBox, mirrorCubeMaterial );
  mirrorCube.position.set(3,2,-5);
  mirrorCubeCamera.position = mirrorCube.position;
  scene.add(mirrorCube);  
*/

//create mirror v2
verticalMirror = new THREE.Mirror( renderer, camera, { clipBias: 0.01, textureWidth: w, textureHeight: h, color:0x999999, debugMode:false} );

var verticalMirrorMesh = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2.5, 0.5 ), verticalMirror.material );
verticalMirrorMesh.add( verticalMirror );
verticalMirrorMesh.position.x = 3;
verticalMirrorMesh.position.y = 2;
verticalMirrorMesh.position.z = -5;
scene.add( verticalMirrorMesh );

// Request animation frame loop function
function animate() {

  var delta = clock.getDelta();
  cube.rotation.x += 0.01;
  annie.update(750 * delta);

/*  var currRenderFunc = renderer.render
  renderer.render = origRenrerFunc;
  mirrorCube.visible = false;
  mirrorCubeCamera.updateCubeMap( renderer, scene );
  mirrorCube.visible = true;
  renderer.render = currRenderFunc;
*/



  // Update VR headset position and apply to camera.
  controls.update();

  verticalMirror.rotation.x = camera.rotation.x + 0.1;
  verticalMirror.rotation.y = camera.rotation.y - 0.05;
  verticalMirror.rotation.z = camera.rotation.z;

  var currRenderFunc = renderer.render
  renderer.render = origRenderFunc;
  verticalMirror.render();
  renderer.render = currRenderFunc;


  // Render the scene through the manager.
  manager.render(scene, camera);

  //renderer.render();


  // Render the scene through the VREffect.
  //effect.render( scene, camera );  

  requestAnimationFrame( animate );
}

// Kick off animation loop
animate();

/*
var stats = new Stats();
stats.setMode( 0 ); // 0: fps, 1: ms, 2: mb

// align top-left
stats.domElement.style.position = 'absolute';
stats.domElement.style.left = '0px';
stats.domElement.style.top = '0px';

document.body.appendChild( stats.domElement );

var update = function () {

    stats.begin();

    animate();

    stats.end();

    requestAnimationFrame( update );

};

requestAnimationFrame( update );
*/

// Listen for keyboard event and zero positional sensor on appropriate keypress.
function onKey(event) {
  if (event.keyCode == 90) { // z
    controls.zeroSensor();
  }
};

window.addEventListener('keydown', onKey, true);


// Handle window resizes
function onWindowResize() {
  camera.aspect = w / h;
  camera.updateProjectionMatrix();

  //effect.setSize( w, h );
}

window.addEventListener('resize', onWindowResize, false);

</script>

</html>
