<!DOCTYPE html>

<html lang="en">
<head>
<title>Web VR boilerplate (Cardboard and Oculus)</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<style>
body {
  background-color: #000;
  color: #fff;
  margin: 0px;
  padding: 0;
  overflow: hidden;
}
</style>
</head>

<body>
</body>

<!--
  three.js 3d library
  -->
<script src="js/deps/three.min.73.js"></script>
<script src="js/deps/stats.min.js"></script>

<!--
  VRControls.js acquires positional information from connected VR devices and applies the transformations to a three.js camera object.
   -->
<!--<script src="js/deps/PhoneVR.js"></script>-->   
<script src="js/deps/VRControls.js"></script>

<!--
  VREffect.js handles stereo camera setup and rendering.
  -->
<script src="js/deps/VREffect.js"></script>

<!--
  A polyfill for WebVR using the Device{Motion,Orientation}Event API.
  -->
<script src="js/deps/webvr-polyfill.js"></script>

<!--
  Helps enter and exit VR mode, provides best practices while in VR.
  -->
<script src="js/webvr-manager.js"></script>

<script src="js/vreticle.js"></script>

<script src="js/texture_animator.js"></script>
<script src="js/mirror.js"></script>

<script>

//var panoramasArray = ["car1.jpg","car2.jpg","car3.jpg"];
var panoramasArray = ["car1.jpg"];
var panoramaNumber = Math.floor(Math.random()*panoramasArray.length);

var container = document.getElementById('container');
container = document.body; 

var w = container.offsetWidth || window.innerWidth;
var h = container.offsetHeight || window.innerHeight;

//Setup three.js WebGL renderer
var renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(window.devicePixelRatio);
var origRenderFunc = renderer.render;

// Append the canvas element created by the renderer to document body element.
//document.body.appendChild(renderer.domElement);
container.appendChild(renderer.domElement);

// Create a three.js scene.
var scene = new THREE.Scene();

// Create a three.js camera.
var camera = new THREE.PerspectiveCamera(75, w / h, 0.3, 10000);

// Apply VR headset positional data to camera.
var controls = new THREE.VRControls(camera);


// Apply VR stereo rendering to renderer.
var effect = new THREE.VREffect(renderer);
effect.setSize(w, h);

// Create a VR manager helper to enter and exit VR mode.
var manager = new WebVRManager(renderer, effect);

//create gaze interaction manager
var reticle = vreticle.Reticle(camera);
scene.add(camera);

var clock = new THREE.Clock();


// creation of a big sphere geometry
var sphere = new THREE.SphereGeometry(100, 100, 40, 1.5);
sphere.applyMatrix(new THREE.Matrix4().makeScale(-1, 1, 1));
 
// creation of the sphere material
var sphereMaterial = new THREE.MeshBasicMaterial();
sphereMaterial.map = THREE.ImageUtils.loadTexture(panoramasArray[panoramaNumber])
//MY: sphereMaterial.alphaMap = (new THREE.TextureLoader()).load("car1_interior_mirror_mask.png");
sphereMaterial.alphaTest = 0.5; 


// geometry + material = mesh (actual object)
var sphereMesh = new THREE.Mesh(sphere, sphereMaterial);
scene.add(sphereMesh);



//sample 3 d object with animated texture
var logo = (new THREE.TextureLoader()).load("kbb1024x128.png");
var annie = new TextureAnimator( logo, 8, 1, 8, 75 ); // texture, #horiz, #vert, #total, duration.


var materials = [  
  new THREE.MeshBasicMaterial({color: 0x000484}),
 new THREE.MeshBasicMaterial({map: logo}),   
  new THREE.MeshBasicMaterial({color: 0x000464}),  
  new THREE.MeshBasicMaterial({color: 0x000444}),
  new THREE.MeshBasicMaterial({color: 0x000424}),
  new THREE.MeshBasicMaterial({color: 0x000404})

];

var cubeMaterial = new THREE.MeshFaceMaterial( materials );

var cube = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1.5, 1.5), cubeMaterial);
cube.position.z = -5;
cube.position.x = 5;
scene.add(cube);

cube.gazing_duration = function(){
  reticle.set_text("this is cube");
}

cube.ongazeover = function(){
  //this.material = reticle.get_random_hex_material();
}

cube.ongazeout = function(){
  //this.material = cubeMaterial;
}

reticle.add_collider(cube);



// create mirror v1

  
  mirrorCubeCamera = new THREE.CubeCamera( 1, 1000, 512 );
  //mirrorCubeCamera = new THREE.PerspectiveCamera(90, 0.1, 10000, 512 );
  mirrorCubeCamera.renderTarget.minFilter = THREE.LinearMipMapLinearFilter;
  scene.add( mirrorCubeCamera );
  
  
  var mirrorCubeMaterial = new THREE.MeshBasicMaterial( { envMap: mirrorCubeCamera.renderTarget } );

  var mirrorBox = new THREE.BoxGeometry(130, 100, 0.1);
  mirrorCube = new THREE.Mesh( mirrorBox, mirrorCubeMaterial );
  mirrorCube.position.set(150,45,-200);
  scene.add(mirrorCube);  
  
  mirrorCubeCamera.position = mirrorCube.position;
  mirrorCubeCamera.position.z = mirrorCubeCamera.position.z - 50;

  /*
  mirrorSphereGeo = new THREE.SphereGeometry(100.01, 100, 40, 1.5);
  mirrorSphereGeo.applyMatrix(new THREE.Matrix4().makeScale(-1, 1, 1));
  mirrorSphere = new THREE.Mesh(mirrorSphereGeo, mirrorCubeCamera);
  mirrorSphere.position.set(0,0,0);
  scene.add(mirrorSphere);
*/

//create mirror v2
/*var verticalMirror = new THREE.Mirror( renderer, camera, { clipBias: 0.03, textureWidth: w, textureHeight: h, color:0x999999, debugMode:true} );
verticalMirror.material.alphaMap = (new THREE.TextureLoader()).load("car1_interior_mirror_mask_inv.png");
verticalMirror.material.alphaTest = 0.5; 
verticalMirror.transparent = true;

var mirrorSphere = new THREE.SphereGeometry(100.01, 100, 40, 1.5);
mirrorSphere.applyMatrix(new THREE.Matrix4().makeScale(-1, 1, 1));

var mirrorDefault = new THREE.PlaneBufferGeometry( 1000, 1000 );

var verticalMirrorMesh = new THREE.Mesh( mirrorSphere, verticalMirror.material );
verticalMirrorMesh.add( verticalMirror );
//verticalMirrorMesh.position.x = 75;
//verticalMirrorMesh.position.y = 40;
//verticalMirrorMesh.position.z = -99;
scene.add( verticalMirrorMesh );
*/

// Request animation frame loop function
function animate() {

  var delta = clock.getDelta();
  cube.rotation.x += 0.01;
  annie.update(750 * delta);




  // Update VR headset position and apply to camera.
  controls.update();

  mirrorCubeCamera.rotation.x = -camera.rotation.x + 0.2;
  mirrorCubeCamera.rotation.y = camera.rotation.y - 0.3;
  mirrorCubeCamera.rotation.z = camera.rotation.z;

  var currRenderFunc = renderer.render
  renderer.render = origRenderFunc;
  mirrorCube.visible = false;
  mirrorCubeCamera.updateCubeMap( renderer, scene );
  //mirrorCubeCamera.updateProjectionMatrix();
  mirrorCube.visible = true;
  renderer.render = currRenderFunc;


  //verticalMirror.rotation.x = camera.rotation.x + 0.2;
  //verticalMirror.rotation.y = camera.rotation.y - 0.3;
  //verticalMirror.rotation.x = -camera.rotation.x;
  //verticalMirror.rotation.y = -camera.rotation.y;
  //verticalMirror.rotation.z = camera.rotation.z;

//  var currRenderFunc = renderer.render
//  renderer.render = origRenderFunc;
//  verticalMirror.render();
//  renderer.render = currRenderFunc;


  // Render the scene through the manager.
  manager.render(scene, camera);

  //renderer.render();

  reticle.reticle_loop();


  // Render the scene through the VREffect.
  //effect.render( scene, camera );  

  requestAnimationFrame( animate );
}

// Kick off animation loop
animate();

/*
var stats = new Stats();
stats.setMode( 0 ); // 0: fps, 1: ms, 2: mb

// align top-left
stats.domElement.style.position = 'absolute';
stats.domElement.style.left = '0px';
stats.domElement.style.top = '0px';

document.body.appendChild( stats.domElement );

var update = function () {

    stats.begin();

    animate();

    stats.end();

    requestAnimationFrame( update );

};

requestAnimationFrame( update );
*/

// Listen for keyboard event and zero positional sensor on appropriate keypress.
function onKey(event) {
  if (event.keyCode == 90) { // z
    controls.zeroSensor();
  }
};

window.addEventListener('keydown', onKey, true);


// Handle window resizes
function onWindowResize() {
  camera.aspect = w / h;
  camera.updateProjectionMatrix();

  //effect.setSize( w, h );
}

window.addEventListener('resize', onWindowResize, false);

</script>

</html>
